id: 8d9bb35f8cb74076abdb84133fd2bc61
parent_id: 
item_type: 1
item_id: ee272aa955764f5eb6da3607eb464319
item_updated_time: 1582548191334
title_diff: "@@ -0,0 +1,15 @@\n+red-black trees\n"
body_diff: "@@ -0,0 +1,10275 @@\n+This article is the somewhat delayed followup to %5BTrees%C2%A0I%5D(http://lwn.net/Articles/175432/), which looked at the radix tree interface. Along with radix trees, the kernel contains an implementation of a data structure known as a %22red-black tree.%22 These trees (known as %22rbtrees%22 within the kernel) are a form of semi-balanced binary tree. Each node in the tree contains a value and up to two children; the node's value will be greater than that of all children in the %5B!%5B%5C%5BRed-black tree%5C%5D%5D(:/2d0994fe04404f3ba7a62dc59867213d)%5D(http://en.wikipedia.org/wiki/Image:Red-black_tree_example.png) %22left%22 child branch, and less than that of all children in the %22right%22 branch. Thus, it is possible to serialize a red-black tree by performing a depth-first, left-to-right traversal.%0A%0AEvery node in a red-black tree is considered to be colored either red or black, with the root always being black. There is a somewhat complicated set of rules on how nodes should be colored, and, in particular, how the colors of the nodes should be used to make decisions on when and how to rebalance the tree. This article will not go into the details of the red-black tree mechanism, especially since that mechanism is well described by %5Bthe Wikipedia red-black tree article%5D(http://en.wikipedia.org/wiki/Red-black_tree) (which is also the source of the image used here). Instead, we'll focus on how red-black trees are used in the Linux kernel.%0A%0AThe complex rules for red-black trees do bring some advantages. Since it is a binary tree, a red-black tree can perform lookups in logarithmic time. If the tree is properly maintained, the longest path to a leaf node in the tree will never be more than twice as long as the shortest path - in other words, the tree is always in approximate balance. But the property which is arguably most useful in the kernel context is the fact that insertions and deletions are (1)%C2%A0fast, and (2)%C2%A0provably bounded in time. All the work that the kernel developers have put into reducing latencies would be wasted if a data structure were to simply go off for an indeterminate period of time rebalancing itself. Users of red-black trees pay a small lookup cost because the tree is not perfectly balanced, but, in return, they get fast, bounded insertion and deletion operations. A red-black tree can, thus, be indicated in situations where nodes come and go frequently.%0A%0AThere are a number of red-black trees in use in the kernel. The anticipatory, deadline, and CFQ I/O schedulers all employ rbtrees to track requests; the packet CD/DVD driver does the same. The high-resolution timer code uses an rbtree to organize outstanding timer requests. The ext3 filesystem tracks directory entries in a red-black tree. Virtual memory areas (VMAs) are tracked with red-black trees, as are epoll file descriptors, cryptographic keys, and network packets in the %22hierarchical token bucket%22 scheduler.%0A%0AThe process of using a red-black tree starts by including %3Clinux/rbtree.h%3E. This is one of the trickier kernel data structures to use, however. When designing a general data structure for a language like C, the developer must always decide how to include arbitrary types within the structure, and how to make comparisons between them. The person who implemented Linux rbtrees (the copyright in the code is to Andrea Arcangeli) made these decisions:%0A%0A*   Structures which are to be part of an rbtree must include a struct rb_node within them; there are no void%C2%A0* pointers to separate objects. This is a common way of implementing kernel data structures, and so will not surprise too many people.%0A*   There is no %22compare two objects%22 callback used in the rbtree code. Instead, users of rbtrees must, for all practical purposes, write the top-level search and insertion functions themselves, using lower-level rbtree primitives. As a result, using an rbtree is a bit more work, and the data structure is rather less opaque than our computer science teachers would have liked. What is gained in return, however, is a faster overall implementation without a bunch of indirect function calls in the hottest part of the tree traversal loops.%0A%0AIt should also be remembered that an rbtree, like many other kernel data structures, implements no locking of its own. Any code which uses an rbtree must implement its own mutual exclusion to keep the tree from being corrupted. Usually, that locking will fit well with the scheme already being used by that code anyway, so there is no need for an independent locking mechanism.%0A%0AThe root of a red-black tree has the type struct rb_root; a tree can be initialized to the empty state with a line like:%0A%0A    struct rb%5C_root the%5C_root = RB_ROOT;%0A%0AAssume, for a moment, that we have a red-black tree which is already full of interesting data. Traversal of that tree (which does not involve searching) is straightforward:%0A%0A    struct rb%5C_node %5C*rb%5C_first(struct rb_root %5C*tree);%0A    struct rb%5C_node %5C*rb%5C_last(struct rb_root %5C*tree);%0A    struct rb%5C_node %5C*rb%5C_next(struct rb_node %5C*node);%0A    struct rb%5C_node %5C*rb%5C_prev(struct rb_node %5C*node);%0A%0AA call to rb_first() will return a pointer to the first entry in the tree, while rb_last() returns the final entry. Moving forward and backward through the tree is a simple matter of calling rb_next() and rb_prev(). In all of these cases, a return value of NULL indicates that the requested node does not exist.%0A%0ASince the rb_node structures are embedded within some other structure of interest, finding the rb_node is a simple matter of using the right structure field. A call to one of the above functions will return a pointer to the embedded rb_node structure, however, and not the containing structure which is, normally, what the programmer really wants. This is the situation that the container_of() macro was created for, but, in this case, there is no need to use container_of() directly. Instead, use rb_entry():%0A%0A    rb_entry(pointer, type, member);%0A%0AWhere pointer is a pointer to an rb_node structure, type is the type of the containing structure, and member is the name of the rb_node structure within the container.%0A%0ASearching an existing tree for a value is simply a matter of starting at the root, then, for each node, comparing the value of that node against the target and following the left or right branch as necessary. So all rbtree search code tends to look like the following:%0A%0A    struct my%5C_stuff %5C*my%5C_rb%5C_search(struct rb%5C_root %5C*root, int value)%0A    %7B%0A        struct rb%5C_node %5C*node = root-%3Erb%5C_node;  /%5C* top of the tree */%0A%0A        while (node)%0A%09%7B%0A%09    struct my%5C_stuff *stuff = rb%5C_entry(node, struct my_stuff, node);%0A%0A%09    if (stuff-%3Ecoolness %3E value)%0A%09%09node = node-%3Erb_left;%0A%09    else if (stuff-%3Ecoolness %3C value)%0A%09%09node = node-%3Erb_right;%0A%09    else%0A%09%09return stuff;  /* Found it */%0A  %09%7D%0A%09return NULL;%0A    %7D%0A%0AHere, we are searching for a struct my_stuff whose coolness field matches the given value. An integer value is used for simplicity, but not all uses need be so simple. If the coolness of the root node is greater than the target value, then that value must be found in the left branch of the tree (if it is in the tree at all), so the search follows the rb_left branch and starts over. A search value greater than the current node's value indicates that the right branch should be used instead. Eventually this function will either find an exact match, or hit the bottom of the tree.%0A%0AThe insertion case is a little trickier. The code must traverse the tree until it finds the leaf node where the insertion should take place. Once it has found that spot, the new node is inserted as a %22red%22 node, and the tree is rebalanced if need be. Insertion code tends to have this form:%0A%0A    void my%5C_rb%5C_insert(struct rb%5C_root %5C*root, struct my%5C_stuff %5C*new)%0A    %7B%0A        struct rb%5C_node %5C*%5C*link = &root-%3Erb%5C_node, %5C*parent;%0A%09int value = new-%3Ecoolness;%0A%0A%09/%5C* Go to the bottom of the tree */%0A%09while (*link)%0A%09%7B%0A%09    parent = *link;%0A%09    struct my%5C_stuff *stuff = rb%5C_entry(parent, struct my_stuff, parent);%0A%0A%09    if (stuff-%3Ecoolness %3E value)%0A%09%09link = &(*link)-%3Erb_left;%0A%09    else%0A%09%09link = &(*link)-%3Erb_right;%0A%09%7D%0A%0A%09/%5C* Put the new node there */%0A%09rb%5C_link%5C_node(new, parent, link);%0A%09rb%5C_insert%5C_color(new, root);%0A    %7D%0A%0AIn this case, the traversal of the tree looks similar to the search case. However, the link pointer is doubly indirected; in the end, it will be used to tell the rbtree code which branch pointer (rb_left or rb_right) should be set to point to the new entry. The code follows the tree all the way to the bottom, at which point the parent pointer identifies the parent of the new node, and link points to the appropriate field within parent. Then, a call is made to:%0A%0A    void rb%5C_link%5C_node(struct rb%5C_node *new%5C_node,%0A                      struct rb_node *parent,%0A%09%09      struct rb_node **link);%0A%0AThis call will link the new node into the tree as a red node. After this call, however, the tree may no longer meet all the requirements for a red-black tree, and may thus need to be rebalanced. That work is done by calling:%0A%0A    void rb%5C_insert%5C_color(struct rb%5C_node %5C*new%5C_node, struct rb_root %5C*tree);%0A%0AOnce that step is complete, the tree will be in consistent form.%0A%0AThere is an important assumption built into the above example: the new value being inserted into the tree is not already present there. If that assumption is not warranted, a corrupted tree could result. If the possibility of a duplicated insertion exists, the code must be careful to test for an exact match (as is done in the search case) and stop (without inserting the node) if that match is found.%0A%0ARemoval of a node from a tree is simpler; simply call:%0A%0A    void rb%5C_erase(struct rb%5C_node %5C*victim, struct rb_root %5C*tree);%0A%0AAfter the call, victim will no longer be part of tree, which may have been rebalanced as part of the operation. If one tree entry is being replaced by another with the same value, however, there is no need to go through the removal and insertion process. Instead, use:%0A%0A    void rb%5C_replace%5C_node(struct rb_node *old, %0A                         struct rb_node *new,%0A%09%09%09 struct rb_root *tree);%0A%0AThis call will quickly remove old from the tree, substituting new in its place. If new does not have the same value as old, however, the tree will be corrupted.\n"
metadata_diff: {"new":{"id":"ee272aa955764f5eb6da3607eb464319","parent_id":"cd72a843f7b74732a4f4ba56fdc7ac7f","latitude":"0.00000000","longitude":"0.00000000","altitude":"0.0000","author":"","source_url":"https://lwn.net/Articles/184495/","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2020-02-24T12:45:13.917Z
created_time: 2020-02-24T12:45:13.917Z
type_: 13