id: c83685d2586445ffaceed1ea7352697d
parent_id: 
item_type: 1
item_id: e373015e1efa4410b075580dfbd3d65c
item_updated_time: 1582542496218
title_diff: "@@ -0,0 +1,11 @@\n+Radix trees\n"
body_diff: "@@ -0,0 +1,8892 @@\n+The kernel includes a number of library routines for the implementation of useful data structures. Among those are two types of trees: radix trees and red-black trees. This article will have a look at the radix tree API, with red-black trees to follow in the future.%0A%0AWikipedia has %5Ba radix tree article%5D(http://en.wikipedia.org/wiki/Radix_tree), but Linux radix trees are not well described by that article. A Linux radix tree is a mechanism by which a (pointer) value can be associated with a (long) integer key. It is reasonably efficient in terms of storage, and is quite quick on lookups. Additionally, radix trees in the Linux kernel have some features driven by kernel-specific needs, including the ability to associate tags with specific entries.%0A%0A!%5B%5C%5Bradix tree node%5C%5D%5D(:/c008ca8ca10240cb850dd68b48b2617b) %0A%0AThe cheesy diagram on the right shows a leaf node from a Linux radix tree. The node contains a number of slots, each of which can contain a pointer to something of interest to the creator of the tree. Empty slots contain a NULL pointer. These trees are quite broad - in the 2.6.16-rc kernels, there are 64 slots in each radix tree node. Slots are indexed by a portion of the (long) integer key. If the highest key value is less than 64, the entire tree can be represented with a single node. Normally, however, a rather larger set of keys is in use - otherwise, a simple array could have been used. So a larger tree might look something like this:%0A%0A!%5B%5C%5Bbig radix tree%5C%5D%5D(:/1dc8a0b3a0a04d138b2cd2ce3685559a)%0A%0AThis tree is three levels deep. When the kernel goes to look up a specific key, the most significant six bits will be used to find the appropriate slot in the root node. The next six bits then index the slot in the middle node, and the least significant six bits will indicate the slot containing a pointer to the actual value. Nodes which have no children are not present in the tree, so a radix tree can provide efficient storage for sparse trees.%0A%0ARadix trees have a few users in the mainline kernel tree. The PowerPC architecture uses a tree to map between real and virtual IRQ numbers. The NFS code attaches a tree to relevant inode structures to keep track of outstanding requests. The most widespread use of radix trees, however, is in the memory management code. The address_space structure used to keep track of backing store contains a radix tree which tracks in-core pages tied to that mapping. Among other things, this tree allows the memory management code to quickly find pages which are dirty or under writeback.%0A%0AAs is typical with kernel data structures, there are two modes for declaring and initializing radix trees:%0A%0A%60%60%60%0A#include %3Clinux/radix-tree.h%3E%0A%0ARADIX_TREE(name, gfp_mask);  /* Declare and initialize */%0A%0Astruct radix_tree_root my_tree;%0AINIT_RADIX_TREE(my_tree, gfp_mask);%0A%60%60%60%0A%0AThe first form declares and initializes a radix tree with the given name; the second form performs the initialization at run time. In either case, a gfp_mask must be provided to tell the code how memory allocations are to be performed. If radix tree operations (insertions, in particular) are to be performed in atomic context, the given mask should be GFP_ATOMIC.%0A%0AThe functions for adding and removing entries are straightforward:%0A%0A    int radix%5C_tree%5C_insert(struct radix%5C_tree%5C_root *tree, unsigned long key, %0A                          void *item);%0A    void %5C*radix%5C_tree%5C_delete(struct radix%5C_tree%5C_root %5C*tree, unsigned long key);%0A%0AA call to radix%5C_tree%5C_insert() will cause the given item to be inserted (associated with key) in the given tree. This operation may require memory allocations; should an allocation fail, the insertion will fail and the return value will be -ENOMEM. The code will refuse to overwrite an existing entry; if key already exists in the tree, radix%5C_tree%5C_insert() will return -EEXIST. On success, the return value is zero. radix%5C_tree%5C_delete() removes the item associated with key from tree, returning a pointer to that item if it was present.%0A%0AThere are situations where failure to insert an item into a radix tree can be a significant problem. To help avoid such situations, a pair of specialized functions are provided:%0A%0A    int radix%5C_tree%5C_preload(gfp%5C_t gfp%5C_mask);%0A    void radix%5C_tree%5C_preload_end(void);%0A%0AThis function will attempt to allocate sufficient memory (using the given gfp_mask) to guarantee that the next radix tree insertion cannot fail. The allocated structures are stored in a per-CPU variable, meaning that the calling function must perform the insertion before it can schedule or be moved to a different processor. To that end, radix%5C_tree%5C_preload() will, when successful, return with preemption disabled; the caller must eventually ensure that preemption is enabled again by calling radix%5C_tree%5C_preload_end(). On failure, -ENOMEM is returned and preemption is _not_ disabled.%0A%0ARadix tree lookups can be done in a few ways:%0A%0A    void %5C*radix%5C_tree%5C_lookup(struct radix%5C_tree%5C_root %5C*tree, unsigned long key);%0A    void %5C*%5C*radix%5C_tree%5C_lookup%5C_slot(struct radix%5C_tree_root %5C*tree, unsigned long key);%0A    unsigned int radix%5C_tree%5C_gang%5C_lookup(struct radix%5C_tree_root *root, %0A                                        void **results,%0A%09%09%09%09%09unsigned long first_index, %0A%09%09%09%09%09unsigned int max_items);%0A%0AThe simplest form, radix%5C_tree%5C_lookup(), looks for key in the tree and returns the associated item (or NULL on failure). radix%5C_tree%5C_lookup_slot() will, instead, return a pointer to the slot holding the pointer to the item. The caller can, then, change the pointer to associate a new item with the key. If the item does not exist, however, radix%5C_tree%5C_lookup_slot() will not create a slot for it, so this function cannot be used in place of radix%5C_tree%5C_insert().%0A%0AFinally, a call to radix%5C_tree%5C_gang_lookup() will return up to max_items items in results, with ascending key values starting at first_index. The number of items returned may be less than requested, but a short return (other than zero) does not imply that there are no more values in the tree.%0A%0AOne should note that none of the radix tree functions perform any sort of locking internally. It is up to the caller to ensure that multiple threads do not corrupt the tree or get into other sorts of unpleasant race conditions. Nick Piggin currently has a patch circulating which would use read-copy-update to free tree nodes; this patch would allow lookup operations to be performed without locking as long as (1)%C2%A0the resulting pointer is only used in atomic context, and (2)%C2%A0the calling code avoids creating race conditions of its own. It is not clear when that patch might be merged, however.%0A%0AThe radix tree code supports a feature called %22tags,%22 wherein specific bits can be set on items in the tree. Tags are used, for example, to mark memory pages which are dirty or under writeback. The API for working with tags is:%0A%0A    void %5C*radix%5C_tree%5C_tag%5C_set(struct radix%5C_tree_root %5C*tree,%0A%09%09%09unsigned long key, int tag);%0A    void %5C*radix%5C_tree%5C_tag%5C_clear(struct radix%5C_tree_root %5C*tree,%0A%09%09%09unsigned long key, int tag);%0A    int radix%5C_tree%5C_tag%5C_get(struct radix%5C_tree_root *tree,%0A%09%09%09unsigned long key, int tag);%0A%0Aradix%5C_tree%5C_tag_set() will set the given tag on the item indexed by key; it is an error to attempt to set a tag on a nonexistent key. The return value will be a pointer to the tagged item. While tag looks like an arbitrary integer, the code as currently written allows for a maximum of two tags. Use of any tag value other than zero or one will silently corrupt memory in some undesirable place; consider yourself warned.%0A%0ATags can be removed with radix%5C_tree%5C_tag_clear(); once again, the return value is a pointer to the (un)tagged item. The function radix%5C_tree%5C_tag_get() will check whether the item indexed by key has the given tag set; the return value is zero if key is not present, -1 if key is present but tag is not set, and +1 otherwise. This function is currently commented out in the source, however, since no in-tree code uses it.%0A%0AThere are two other functions for querying tags:%0A%0A    int radix%5C_tree%5C_tagged(struct radix%5C_tree%5C_root *tree, int tag);%0A    unsigned int radix%5C_tree%5C_gang%5C_lookup%5C_tag(struct radix%5C_tree%5C_root *tree, %0A                                            void **results,%0A%09%09%09%09%09    unsigned long first_index, %0A%09%09%09%09%09    unsigned int max_items, %0A%09%09%09%09%09    int tag);%0A%0Aradix%5C_tree%5C_tagged() returns a non-zero value if any item in the tree bears the given tag. A list of items with a given tag can be obtained with radix%5C_tree%5C_gang%5C_lookup%5C_tag().%0A%0AIn concluding, we can note one other interesting aspect of the radix tree API: there is no function for destroying a radix tree. It is, evidently, assumed that radix trees will last forever. In practice, deleting all items from a radix tree will free all memory associated with it other than the root node, which can then be disposed of normally.\n"
metadata_diff: {"new":{"id":"e373015e1efa4410b075580dfbd3d65c","parent_id":"cd72a843f7b74732a4f4ba56fdc7ac7f","latitude":"0.00000000","longitude":"0.00000000","altitude":"0.0000","author":"","source_url":"https://lwn.net/Articles/175432/","is_todo":0,"todo_due":0,"todo_completed":0,"source":"joplin-desktop","source_application":"net.cozic.joplin-desktop","application_data":"","order":0,"markup_language":1,"is_shared":0},"deleted":[]}
encryption_cipher_text: 
encryption_applied: 0
updated_time: 2020-02-24T11:11:18.075Z
created_time: 2020-02-24T11:11:18.075Z
type_: 13